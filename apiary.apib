FORMAT: 1A
HOST: https://api.dealini.ch


# Dealini API
Welcome to the Dealini API documentation. We are constantly adding and improving features of this API.
Please add your comments and feedback to the API as comments!

Requests with data (POST / PUT) will be JSON encoded. The Content-Type will be application/json
All responses will to be JSON encoded. The Content-Type will always be application/json

Most API calls are only available after authorization (login). For these calls it is necessary to send the
auth-cookie which is set in the Response of POST /sessions along with the Request. Cookies will also be used
for load balancing, so the consumer of the API should handle cookies the same way a browser would handle cookies.

Some resources can be accessed by an anonymous user, but most resources need a registered user (e.g. with a valid email).
If an anonymous user tries to access a resource available only to registered users, a HTTPForbidden error will be returned.
As over time the resources available to anonymous users might change, a consumer of the API should implement a generic handler
for these cases promting the anonymous user to register only after trying to access the protected route. For this reason the
protected routes are not explicitly mentioned in the documentation.

## General fields always available
* suppress_response_codes: (bool) If this is provided and set to "true", the Error Codes will always return as a HTTP OK (200). The correct HTTP Error Code is stored in the JSOn encoded Error response
* rollback: (bool) If this is set to "true", no changes will be saved in the database. Useful for testing.
* fields (alt: fields[]): (string) Only return these fields/attributes. Must be provided to get optional fields/attributes. "id" is always returned.
    To specify fields from embedded objects (e.g. products inside a deal), the dot-notation can be used (e.g. "product.name" to get only the name attribute)

## Error Codes
Error codes specific for the resources are described at the corresponding resource

* 0: (HTTP 500 - Internal Server Error) Something did not work out as expected. An automatic E-Mail is sent to Dealini and we will look into the problem.
* 1: (HTTP 400 - Bad Request) Generally malformatted input. A detailed description of the error is given in the error description
* 2: (HTTP 401 - Unauthorized) A resource which is only available to logged-in user is requested by an unauthorized user. Either the user is not logged in or his session timed out.
* 3: (HTTP 404 - NotFound) The resource does not exist
* 4: (HTTP 403 - Forbidden) This resource is only available to non-anonymous users
* 5: (HTTP 403 - Forbidden) Tried to change write-protected field without necessary permissions

# Templates
Often-used object templates are described here. later, only the tempaltes will be referred with the respective configuration.

## Image <Image(width, height, optional:fill_mode)>
An image can have multiple versions (resolutions) to look good on all devices (e.g. retina display)

Possible fill_modes are:

* fill: (default) Create an image with the exact given width and height while retaining original proportions.
    Uses only a portion of the original image that fills the given dimensions.
* fit: Change image size to fit in the given width & height while retaining original proportions. All original image parts are visible.
    Both width and height dimensions of the transformed image must not exceed the specified width & height.

Example:

        {
            "url": "https://res.cloudinary.com/dealini/image/upload/sample.jpg",
            "versions": {
                '1x': u'https://res.cloudinary.com/dealini/image/upload/c_fill,h_50,w_50/sample.jpg',
                '2x': u'https://res.cloudinary.com/dealini/image/upload/c_fill,dpr_2.0,h_50,w_50/sample.jpg', 
                'mdpi': u'https://res.cloudinary.com/dealini/image/upload/c_fill,dpr_1.0,h_50,w_50/sample.jpg',
                'hdpi': u'https://res.cloudinary.com/dealini/image/upload/c_fill,dpr_1.5,h_50,w_50/sample.jpg',
                'xhdpi': u'https://res.cloudinary.com/dealini/image/upload/c_fill,dpr_2.0,h_50,w_50/sample.jpg',
                'xxhdpi': u'https://res.cloudinary.com/dealini/image/upload/c_fill,dpr_3.0,h_50,w_50/sample.jpg'
            },
        }



# Group Sessions
Creation & removal of sessions. Login and Logout are handled here

## Error-Codes
* 10: (HTTP 400 - Bad Request) "Email and password or the Facebook access token must be provided" - This happens if either the facebook access token, the email or the password werent provided at all
* 11: (HTTP 401 - Unauthorized) "Email or password did not match."
* 12: (HTTP 401 - Unauthorized) "Session does not exist" - The session either never existed or it was already terminated
* 13: (HTTP 400 - Bad Request) "Invalid Facebook access token" - The access token could not be used, either because it is malformatted or expired.
* 14: (HTTP 404 - NotFound) "Could not find user" - The user could not be found based on the provided identification
* 15: (HTTP 401 - Unauthorized) "The user is banned" - The user is marked as banned. Normally the user is informed by email about the reasons.

## Session [/sessions/current]

The session object

Attributes:

* token: (string) encrypted hex-encoded 36 byte (72 chars) session ID
* user_id: (int) ID of the user who owns the session token

+ Model (application/json)

    + Headers

            Set-Cookie: dealinidev_auth=5b068891ae586391d30c4aeed158ce5a6829af58b5bb9280f22c46689c9314b61482edf8; httponly; Path=/

    + Body

            {
                "session": {
                    "token": "Unique72charSHAgeneratedsessionUnique72charSHAgeneratedsession",
                    "user_id": 4809
                }
            }

### Logout a user [DELETE]

+ Response 204

## Sessions collection [/sessions]

### Create a new Session with Email and Password [POST]
The following parameters are available:

* email: (unicode string) login of user
* password: (unicode string) password of user
* fb_access_token: (string) A valid FB access token. If this is given, email&password are ignored
* device_identifier: (string) A unique identifier for the device used for anonymous users

+ Request (application/json)

        {
            "email": "dealinitest1@dealini.ch",
            "password": "de-a-lini"
        }

+ Request with Facebook (application/json)

        {
            "fb_access_token": "AAACukElzvo0BALBn7XKCA6ZAnJ5MZCaDV6JJK4f0XDVUENgqGyRRWLXAUV4yL8MnHaw4JUCzFvBZC7if9ZAsIoVhIuv3TljWxNKVY83eJR6sTX6pOZBqs"
        }

+ Request with device_identifier (application/json)

        {
            "device_identifier": "anystringwhichisunique"
        }

+ Response 200

    [Session][]


# Group Users
All requests belonging to a user, e.g. creating, changing and fetching.

## Error-Codes
* 20: (HTTP 403 - Forbidden) "Invalid email address" - The provided email is not considered a valid email based on some basic regex
* 21: (HTTP 403 - Forbidden) "Email address forbidden" - The provided email domain is on a blacklist (mostly one-time trash email providers), the user must use another email address
* 22: (HTTP 403 - Forbidden) "Password too short" - The password must have at least 6 characters
* 23: (HTTP 403 - Forbidden) "User already exists" - A user with the same email address already registered. Good oportunity to allow the user to re-send the confirmation mail or the password-forgotten dialog
* 24: (HTTP 404 - NotFound) "User does not exist" - No User with this ID ever existed
* 25: (HTTP 400 - Bad Request) "Invalid access_token" - Most likely the access token expired. Other reasons include not having installed the dealini app
    or not having provided the necessary permissions (only email permission is required)
* 26: (HTTP 403 - Forbidden) "Username too short" - The username must have at least one non-blank character
* 27: (HTTP 403 - Forbidden) "Invalid confirmation code" - The user tried to verify with an invalid verification code
* 28: (HTTP 403 - Forbidden) "Invalid or already used mobile number" - The user tried to verify with an invalid or already used mobile number
* 29: (HTTP 403 - Forbidden) "Invalid change of a user attribute" - Most fields of the user cannot be changed.
  Some fields like "state" or "mobile" can only be changed once.

Default attributes:
 * id: (int) ID of the user
 * username: (string) Freely chosen username of the player
 * image: (Image) Location of the users image
 * status_message: (string) Freely setable status message

Optional Attributes:
 * push_notification_channel: (string) Unique name of the player-specific PARSE channel name for push notifications
 * email: (string) Valid email of the user. This is "null" for anonymous users
 * first_name: (string, optional)
 * last_name: (string, optional)
 * phone: (string, optional) 
 * birthday: (isodatetime, optional) 
 * settings: (Settings object) The individual settings of the user, described in "Settings of a user" 
 * number_of_common_friends: (int, optional) Relative to the logged-in user, gives the number of common friends (null: User is a friend).
    This is only set when searching for users (/users?q=...).

## User [/users/{id}]

One player of dealini.ch.
When fetching a single user, the default and the optional attributes are returned.

+ Model (application/json)

    + Body
    
            {
                "user": {
                    "status_message": "Hello World",
                    "username": "dealinitest1",
                    "image": <Image(50, 50)>,
                    "id": 4809,
                    "email": "dealinitest1@dealini.ch",
                    "first_name": "Dealini",
                    "last_name": "Testuser",
                    "phone": "+41445201122",
                    "birthday": "2011-11-21T00:00:00",
                    "settings": null,
                    "number_of_common_friends": null,
                    "push_notification_channel": "56171a345483545d823bf3fab4a6ac2b453f0b3f822386360b0561f7748bd967"
                }
            }

### Fetch a  User [GET]

+ Parameters
    + id (int, required, `4809`) ... The id of the `user` to retrieve. Use "custom" to fetch the currently logged-in user

+ Response 200

    [User][]

### Update a user [PUT]

Read-only fields are:
* id
* number_of_common_friends (changed by adding/deleting friends)
* push_notification_channel
* settings (can be changed, see below)

Write-only fields are:
* password: (string) New user-chosen password
* fb_access_token: (string) Valid facebook access token, account will be connected.

+ Parameters
    + id (int, required, `3`) ... ID of the user
    
+ Request (application/json)

    + Body
    
            {
                "email": "dealinitest1@dealini.ch",
                "password": "bla123",
            }
            
+ Response 200
    
    [User][]


## User collection [/users]

+ Model (application/json)

    + Body

            {
                "users": [
                    {
                        "status_message": "Hello World",
                        "username": "dealinitest1",
                        "image": <Image(50, 50)>,
                        "id": 4809
                    },
                ]
            }

### Create a User [POST]

Create a new user. Will also return a valid new session.

Available parameters:

* username: (string) Will be used as the displayed name in the game.

* email: (string, valid email) The new login name of the user
* password: (string) The new password of the user
or
* access_token: (string, fb access token) an authorized Facebook access token for the user
or
* device_identifier: (string) A unique device identifing token, used to create an limited anonymous user


+ Request (application/json)

        {
            "email": "dealinitest1@dealini.ch",
            "password": "de-a-lini",
            "username": "Dealini Test"
        }

+ Request with FB token (application/json)

        {
            "access_token": "AAACukElzvo0BALBn7XKCA6ZAnJ5MZCaDV6JJK4f0XDVUENgqGyRRWLXAUV4yL8MnHaw4JUCzFvBZC7if9ZAsIoVhIuv3TljWxNKVY83eJR6sTX6pOZBqs"
            "username": "Dealini Test"
        }

+ Request with device_identifier (application/json)

        {
            "device_identifier": "anystringwhichisunique"
        }

+ Response 200

    [User][]

## User collection search [/users{?q}]

### Get multiple users [GET]

+ Parameters
    + q (string, required, `dealinitest1`) ... Searches for exact matches of email and fuzzy matches of username and first+lastname.
        When called as a admin (fromt he dashboard), all fields are searchy fuzzy and additional fields are searched.

+ Response 200 (application/json)

    [User collection][]

## Cards of a user [/users/{user_id}/cards{?deal_id}]
A user has cards which can be traded with other users.

### Get all tradeable cards [GET]

+ Parameters
    + user_id (int, required, `4809`) ... The user for which we want to fetch the cards. *current* for the logged-in user.
    + deal_id (int, optional) ... Filter cards by this dealid

+ Response 200 (application/json)

    + Body

    
            {
                "cards": [
                    {
                        "user_id": 4809,
                        "deal_id": 1012,
                        "number": 1,
                        "quantity": 2
                    },
                    {
                        "user_id": 4809,
                        "deal_id": 1012,
                        "number": 2,
                        "quantity": 1
                    },
                    {
                        "user_id": 4809,
                        "deal_id": 1013,
                        "number": 3,
                        "quantity": 1
                    }
                ]
            }


## Friendships of a user [/users/{user_id}/friendships/{friend_id}]

### Get all friends of this user [GET]

+ Parameters
    + user_id (int, required, `4809`) ... The user for which we want to fetch the friendships. *current* for the logged-in user.

+ Response 200 (application/json)

    + Body

            {
                "friendships": [
                    {
                        "friend_id": 631,
                        "user_id": 4809,
                        "friend": {
                            "username": "Matthias©",
                            "image": <Image(50, 50)>,
                            "id": 631,
                            "status_message": "Hello World"
                        }
                    }
                ]
            }

### Delete a friend [DELETE]

Always "works", even if they were no friends

+ Parameters
    + user_id (int, required, `current`) ... The user who is deleting the friend request. *current* for the logged-in user.
    + friend_id (int, required, `631`) ... The user who is being removed from the friends.

+ Response 204

### Add a friend - accept a friend request [POST]

Only works if a pending friend request is waiting. Will issue a push notification (code=4) to the user.

+ Parameters
    + user_id (int, required, `current`) ... The user who is accepting the friend request. *current* for the logged-in user.

+ Request (application/json)

        {
            "friend_id": 631
        }

+ Response 200 (application/json)

    + Body

            {
                "friendship": {
                    "friend_id": 631,
                    "user_id": 4809,
                    "friend": {
                        "username": "Matthias©",
                        "image": <Image(50, 50)>,
                        "id": 631,
                        "status_message": "Hello World"
                    }
                }
            }

## Settings of a user [/users/{user_id}/settings]

### Get all his settings [GET]

If the settings of another than the logged-in user are checked, only the public settings are returned

+ Parameters
    + user_id (int, required, `4809`) ... The user for which we want to fetch the settings. *current* for the logged-in user.

+ Response 200 (application/json)

    + Body

            {
                "settings": {
                    "id": 4809,
                    "billing_address": {
                        "city": null,
                        "first_name": null,
                        "last_name": null,
                        "country_iso_code": "CH",
                        "title": "Mr",
                        "street": null,
                        "postal_code": null
                    },
                    "use_billing_address_as_shipping_address": true,
                    "shipping_address": {
                        "city": null,
                        "first_name": null,
                        "last_name": null,
                        "country_iso_code": "CH",
                        "title": "Mr",
                        "street": null,
                        "postal_code": null
                    }
                }
            }

### Update a setting [PUT]

+ Parameters
    + user_id (int, required, `4809`) ... The user for which we want to fetch the settings. *current* for the logged-in user.

+ Request (application/json)

        {
            "billing_address": {
                "city": "Stadt",
                "first_name": "Max",
                "last_name": "Mustermann",
                "country_iso_code": "CH",
                "title": "Mr",
                "street": "Strasse 1",
                "postal_code": 1234
            }
        }

+ Response 200 (application/json)

    + Body

            {
                "settings": {
                    "id": 4809,
                    "billing_address": {
                        "city": "Stadt",
                        "first_name": "Max",
                        "last_name": "Mustermann",
                        "country_iso_code": "CH",
                        "title": "Mr",
                        "street": "Strasse 1",
                        "postal_code": "1234"
                    },
                    "use_billing_address_as_shipping_address": true,
                    "shipping_address": {
                        "city": null,
                        "first_name": null,
                        "last_name": null,
                        "country_iso_code": "CH",
                        "title": "Mr",
                        "street": null,
                        "postal_code": null
                    }
                }
            }



# Group FriendRequests

## Error-Codes:
* 160: (HTTP 403 - Forbidden) "The players are already friends" - A friend request can only be made to players who are not friends yet
* 161: (HTTP 403 - Forbidden) "No pending friend request from other player" To accept a friend request,
    there must be a pending friend request from the other player.

## FriendRequest [/friendRequest/{id}]

+ Model (application/json)

    + Body
    
            {
                "friendRequest": {
                    "addressee_id": 631,
                    "requester_id": 4809,
                    "time_created": "2014-04-04T23:59:59",
                }
            }

## FriendRequest collection [/users/{user_id}/friendRequests/{friend_id}]

Alternative URL for /users/current/friendRequests: /friendRequests

+ Model (application/json)

    + Body
    
            {
                "friendRequests": [
                    {
                        "addressee_id": 4809,
                        "requester_id": 631,
                        "time_created": "2014-04-04T23:59:59",
                        "requester": {
                            "id": 631,
                            "username": "Matthias",
                            "image": <Image(50, 50)>,
                            "status_message": "Hello World"
                        }
                    }
                ]
            }

### Get pending friend requests which can be accepted by the player [GET]

+ Parameters
    + user_id (int, required, `current`) ... The user for which we want to fetch the settings. *current* for the logged-in user.
    
+ Response 200 (application/json)

    [FriendRequest collection][]

### Create a new friend request [POST]

Will issue a push notification to the addressee (code=3)

+ Parameters
    + user_id (int, required, `current`) ... The user for which we want to fetch the settings. *current* for the logged-in user.

+ Request (application/json)

    + Body
    
            {
                "addressee_id": 631
            }

+ Response 200 (application/json)

    [FriendRequest][]

### Reject a friend request [DELETE]

+ Parameters
    + user_id (int, required, `current`) ... The user who wants to reject the friend request. *current* for the logged-in user.
    + friend_id (int, required, `631`) ... The user who is being rejected.

+ Response 204
    
    
# Group Codes

## Error-Codes:
* 170: (HTTP 403 - Forbidden) "Code already used by you" - The provided code was used by the logged-in player, go and check cards or instant prizes.
* 171: (HTTP 403 - Forbidden) "Code already used by another player" - The provided code was used by someone other then the logged-in player.
* 172: (HTTP 404 - NotFound) "Code does not exist" -The provided code never existed in our database

## Code [/codes/{code}]

### Use a code to get a card [DELETE]

+ Parameters
    + code (string, required, `AAAABBBBCCCC`) ... The code which should be converted into the card or isntant prize

+ Response 200 (application/json)

    + Body

            {
                "code": {
                    "type": "card",
                    "code": "AAAABBBBCCCC",
                    "card_unit": {
                        "deal_id": 1012,
                        "number": 1,
                        "image": <Image(66, 88)>,
                        "name": "04.1"
                    }
                    "instant_prize_card": null
                }
            }


# Group Credits

Credits represent flowpacks or special offers which the player can use to get more cards.

## Error-Codes:
* 30: (HTTP 403 - Forbidden) "Access denied to credits of another user" - The logged-in user does not own the queried credit

## Credit [/users/{user_id}/credits/{credit_id}]

### Use a code to get a card [DELETE]

When a credit is used, either one specific card or several cards (3 right now) are given to the user.
This is reported as a list of cardUnits and instant_prize_cards

+ Parameters
    + user_id (int, required, `4809`) ... The user owning the credit
    + credit_id (int, required, `1`) ... The id of the credit which should be used

+ Response 200 (application/json)

    + Body

            {
                "cardUnits": [
                    {
                        "image": <Image(66, 88)>,
                        "deal_id": 1012,
                        "number": 1,
                        "name": "04.1"
                    },
                    {
                        "image": <Image(66, 88)>,
                        "deal_id": 1012,
                        "number": 2,
                        "name": "04.2"
                    }
                ]
                "instant_prize_cards": [
                    {
                        "id": 1,
                        "name": "Eat.ch 5 CHF Gutschein",
                        "image_card": <Image(66, 88)>
                    }
                ]
            }

## Credits Collection [/users/{user_id}/credits]

### Get unredeemed credits belonging to the user [GET]

These credits are usually given to the user when he buys one or multiple flowpacks.

+ Parameters
    + user_id (int, required, `4809`) ... The user owning the credit

+ Response 200 (application/json)

    + Body

            {
                "credits": [
                    {
                        "id": 1,
                        "user_id": 4809
                    }
                ]
            }

# Group InstantPrizeCards

## Error-Codes:
* 180: (HTTP 403 - Forbidden) "Forbidden to access instant prize card belonging to another user"

## InstantPrizeCard [/instantPrizeCards/{cardid}]

The instant prize itself is included by default

+ Model (application/json)

    + Body
    
            {
                "instantPrizeCard": {
                    "id": 1,
                    "instant_prize": {
                        "id": 1,
                        "name": "Eat.ch 5 CHF Gutschein",
                        "image_product": <Image(400, 300)>,
                        "image_card": <Image(66, 88)>,
                        "description": "Hol dir jetzt dein Essen nach Hause und spare dabei 5 CHF!",
                        "terms_html": "<ul><li>Nicht kummulierbar</li><li>Gültig bis 31.12.2014</li></ul>",
                        "how_to_html": "<h1>So funktionierts</h1><p>Du musst einfach auf eat.ch gehen, bestellen und den Gutscheincode eingeben.</p>",
                        "company_address": {
                            "company_name": "Eat.ch",
                            "street": "Strasse 1",
                            "city": "Zürich",
                            "postal_code": "8000",
                            "country_iso_code": "CH"
                        }
                        "redemption_type": "code",
                        "redemption_infos": {
                            "shop_url": "http://www.eat.ch"
                        },
                    },
                    "user": {
                        "username": "dealinitest1",
                        "image": <Image(50, 50)>,
                        "id": 4809,
                    }
                    "redemption_info": {
                        "code": "abc123def"
                    },
                    "delivery_details": {
                        "email": "test@example.com"
                    },
                    "webview_url": "http://sticker.dealini.ch/#1"
                }
            }

### Get a single instant prize card [GET]

+ Parameters
    + cardid (int, required, `1`) ... The ID of the instant prize card
            
+ Response 200 (application/json)

    [InstantPrizeCard][]

### Update the delivery_details [PUT]

+ Parameters
    + cardid (int, required, `1`) ... The ID of the instant prize card

+ Request (application/json)

    + Body
    
            {
                "delivery_details": {
                    "email": "test@example.com"
                }
            }

+ Response 200 (application/json)

    [InstantPrizeCard][]

## InstantPrizeCards collection [/users/{user_id}/instantPrizeCards]

### All instant prize cards of a user [GET]

+ Parameters
    + user_id (int, required, `4809`) ... The ID of the user owning the cards

+ Response 200 (application/json)

    + Body
    
            {
                "instantPrizeCards": [
                    {
                        "id": 1,
                        "instant_prize": {
                            "id": 1,
                            "name": "Eat.ch 5 CHF Gutschein",
                            "image_card": <Image(66, 88)>
                        },
                        "webview_url": "http://sticker.dealini.ch/#1"
                    }
                ]
            }


# Group Deals
A deal is an offer which can be redeemed if a certain amount of distinct cards have been collected.

## Error-Codes:
* 40: (HTTP 404 - NotFound) "Card not found" - The card does not exist in the database (anymore).
    When a deal cannot be collected anymore, the unsold cards are removed.
* 50: (HTTP 404 - NotFound) "No Deal found" - This deal never existed or the search returned no results
* 51: (HTTP 403 - Forbidden) "Cannot access deal" - This deal is not yet active

## Deal [/deals/{id}]
Deals are products for which the player can collect cards and, by doing that, earn a discount on the product.

Attributes:

* id: (int) ID of the deal
* name: (string) Short name for this deal
* image_logo: (Image) The logo of the deal.
* image_overview: (Image) The image which is displayed when showing a list of deals.
* image_featured: (Image) The image to display when this deal is featured.
* rank: (int) Used for ordering multiple deals, e.g. in the album. Lower rank equals higher position (e.g. rank 1 = topmost deal)
* likes: (int) Number of peoples who favourited this deal
* number: (int) The identifier for this deal in numeric form for display purposes.
* featured: (bool) If the deal should be featured (highlighted) in the album overview

Optional Attributes (Returned by default if a single deal is requested):

* options: (list of dicts) The possible choices for products for this deal
* products: (list of dicts) All valid products for this deal
* show_in_album: (bool) If the deal should be visible in the overview of deals ("album")
* amount_of_distinct_cards: (int) How many cards have to be collected.
* image_background: (Image) The file which can be used as a background image when showing the deal details
* product_images: (list of Image) Different shots of the product or the brand
* tint_color: (string, "#FFFFFF") Hex-coded color of the deal

Admin attributes:
* time_start: (isodatetime) Starting time of the deal
* time_end: (isodatetime) End of the deal - can still be redeemed
* time_redeem_end: (isodatetime) Real end - no redemption anymore


+ Model (application/json)

    + Body

            {
                "deal": {
                    "id": 1012,
                    "name": "Mein Essen",
                    "title": "ist immer das beste Essen",
                    "longdesc": "Gekocht mit viel Liebe und Leidenschaft zum Essen",
                    "terms": "Niederlassung in der Schweiz, Vorkasse",
                    "image_logo": <Image(100, 35, fit)>,
                    "image_overview": <Image(320, 130)>,
                    "rank": 1,
                    "likes": 896,
                    "number": 35,
                    "category_id": 1,
                    "featured": false,
                    "show_in_album": true,
                    "amount_of_distinct_cards": 4,
                    "time_start": "2050-12-31T23:59:59",
                    "time_end": "2051-12-31T23:59:59",
                    "time_redeem_end": "2051-11-31T23:59:59",
                    "image_background": <Image(320, 568)>,
                    "image_featured": <Image(320, 180)>,
                    "product_images": [
                        <Image(320, 200)>,
                        <Image(320, 200)>
                    ],
                    "tint_color": "#d9ac7c",
                    "attributes": [
                        {
                            "id": 1,
                            "name": "Art",
                            "values": [
                                {"id": "1", "name": "Indisch"},
                                {"id": "3", "name": "Schweiz"},
                                {"id": "2", "name": "Tessin"}
                            ]
                        }
                    ],
                    "products": [
                        {
                            "price_in_cents": 10000,
                            "image": <Image(75, 75)>,
                            "configuration": {
                                "1": 1
                            },
                            "id": 1,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        },
                        {
                            "price_in_cents": 10000,
                            "image": <Image(75, 75)>,
                            "configuration": {
                                "1": 2
                            },
                            "id": 3,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        },
                        {
                            "price_in_cents": 10000,
                            "image": <Image(75, 75)>,
                            "configuration": {
                                "1": 3
                            },
                            "id": 4,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        }
                    ]
                }
            }

### Fetch a single deal [GET]

+ Parameters
    + id (int, required, `1012`) ... ID of the deal

+ Response 200
    
    [Deal][]

### update a single deal [PUT]

+ Parameters
    + id (int, required, `1012`) ... ID of the deal

+ Request (application/json)

    + Body

            {
                "deal": {
                    "name": "Mein Essen",
                    "title": "ist immer das beste Essen",
                    "longdesc": "Gekocht mit viel Liebe und Leidenschaft zum Essen",
                    "terms": "Niederlassung in der Schweiz, Vorkasse",
                    "image_logo": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                    "image_overview": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                    "rank": 1,
                    "number": 35,
                    "category_id": 1,
                    "featured": false,
                    "show_in_album": true,
                    "amount_of_distinct_cards": 4,
                    "time_start": "2050-12-31T23:59:59",
                    "time_end": "2051-12-31T23:59:59",
                    "time_redeem_end": "2051-11-31T23:59:59",
                    "image_background": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                    "image_featured": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                    "product_images": [
                        "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                        "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png"
                    ],
                    "tint_color": "#d9ac7c",
                    "attributes": [
                        {
                            "id": 1,
                            "name": "Art",
                            "values": [
                                {"id": "1", "name": "Indisch"},
                                {"id": "3", "name": "Schweiz"},
                                {"id": "2", "name": "Tessin"}
                            ]
                        }
                    ],
                    "products": [
                        {
                            "price_in_cents": 10000,
                            "image": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                            "configuration": {
                                "1": 1
                            },
                            "id": 1,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        },
                        {
                            "price_in_cents": 10000,
                            "image": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                            "configuration": {
                                "1": 2
                            },
                            "id": 3,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        },
                        {
                            "price_in_cents": 10000,
                            "image": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                            "configuration": {
                                "1": 3
                            },
                            "id": 4,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        }
                    ]
                }
            }
            
+ Response 200
    
            {
                "deal": {
                    "name": "Mein Essen",
                    "title": "ist immer das beste Essen",
                    "longdesc": "Gekocht mit viel Liebe und Leidenschaft zum Essen",
                    "terms": "Niederlassung in der Schweiz, Vorkasse",
                    "image_logo": <Image(100, 35, fit)>,
                    "image_overview": <Image(320, 130)>,
                    "rank": 1,
                    "number": 35,
                    "category_id": 1,
                    "featured": false,
                    "show_in_album": true,
                    "amount_of_distinct_cards": 4,
                    "time_start": "2050-12-31T23:59:59",
                    "time_end": "2051-12-31T23:59:59",
                    "time_redeem_end": "2051-11-31T23:59:59",
                    "image_background": <Image(320, 568)>,
                    "image_featured": <Image(320, 180)>,
                    "product_images": [
                        <Image(320, 200)>,
                        <Image(320, 200)>
                    ],
                    "tint_color": "#d9ac7c",
                    "attributes": [
                        {
                            "id": 1,
                            "name": "Art",
                            "values": [
                                {"id": "1", "name": "Indisch"},
                                {"id": "3", "name": "Schweiz"},
                                {"id": "2", "name": "Tessin"}
                            ]
                        }
                    ],
                    "products": [
                        {
                            "price_in_cents": 10000,
                            "image": <Image(75, 75)>,
                            "configuration": {
                                "1": 1
                            },
                            "id": 1,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        },
                        {
                            "price_in_cents": 10000,
                            "image": <Image(75, 75)>,
                            "configuration": {
                                "1": 2
                            },
                            "id": 3,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        },
                        {
                            "price_in_cents": 10000,
                            "image": <Image(75, 75)>,
                            "configuration": {
                                "1": 3
                            },
                            "id": 4,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        }
                    ]
                }
            }

## Deal collection [/deals]

### All active deals [GET]

+ Response 200 (application/json)

    + Headers
    
            Cache-Control: max-age=3600
            Date: Tue, 22 Apr 2014 15:46:23 GMT
            Expires: Tue, 22 Apr 2014 16:46:23 GMT
    
    + Body

            {
                "deals": [
                    {
                        "id": 1012,
                        "name": "Mein Essen",
                        "title": "ist immer das beste Essen",
                        "longdesc": "Gekocht mit viel Liebe und Leidenschaft zum Essen",
                        "terms": "Niederlassung in der Schweiz, Vorkasse",
                        "image_logo": <Image(100, 35, fit),
                        "image_overview": <Image(320, 130)>,
                        "image_featured": <Image(320, 180)>,
                        "rank": 1,
                        "likes": 0,
                        "number": 4,
                        "category_id": 7,
                        "featured": true
                    }
                ]
            }

### create a single deal [POST]

+ Request (application/json)

    + Body

            {
                "deal": {
                    "name": "Mein Essen",
                    "title": "ist immer das beste Essen",
                    "longdesc": "Gekocht mit viel Liebe und Leidenschaft zum Essen",
                    "terms": "Niederlassung in der Schweiz, Vorkasse",
                    "image_logo": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                    "image_overview": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                    "rank": 1,
                    "number": 35,
                    "category_id": 1,
                    "featured": false,
                    "show_in_album": true,
                    "amount_of_distinct_cards": 4,
                    "time_start": "2050-12-31T23:59:59",
                    "time_end": "2051-12-31T23:59:59",
                    "time_redeem_end": "2051-11-31T23:59:59",
                    "image_background": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                    "image_featured": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                    "product_images": [
                        "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                        "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png"
                    ],
                    "tint_color": "#d9ac7c",
                    "attributes": [
                        {
                            "id": 1,
                            "name": "Art",
                            "values": [
                                {"id": "1", "name": "Indisch"},
                                {"id": "3", "name": "Schweiz"},
                                {"id": "2", "name": "Tessin"}
                            ]
                        }
                    ],
                    "products": [
                        {
                            "price_in_cents": 10000,
                            "image": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                            "configuration": {
                                "1": 1
                            },
                            "id": 1,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        },
                        {
                            "price_in_cents": 10000,
                            "image": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                            "configuration": {
                                "1": 2
                            },
                            "id": 3,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        },
                        {
                            "price_in_cents": 10000,
                            "image": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                            "configuration": {
                                "1": 3
                            },
                            "id": 4,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        }
                    ]
                }
            }
            
+ Response 200
    
            {
                "deal": {
                    "id": 1012,
                    "name": "Mein Essen",
                    "title": "ist immer das beste Essen",
                    "longdesc": "Gekocht mit viel Liebe und Leidenschaft zum Essen",
                    "terms": "Niederlassung in der Schweiz, Vorkasse",
                    "image_logo": <Image(100, 35, fit)>,
                    "image_overview": <Image(320, 130)>,
                    "rank": 1,
                    "likes": 896,
                    "number": 35,
                    "category_id": 1,
                    "featured": false,
                    "show_in_album": true,
                    "amount_of_distinct_cards": 4,
                    "time_start": "2050-12-31T23:59:59",
                    "time_end": "2051-12-31T23:59:59",
                    "time_redeem_end": "2051-11-31T23:59:59",
                    "image_background": <Image(320, 568)>,
                    "image_featured": <Image(320, 180)>,
                    "product_images": [
                        <Image(320, 200)>,
                        <Image(320, 200)>
                    ],
                    "tint_color": "#d9ac7c",
                    "attributes": [
                        {
                            "id": 1,
                            "name": "Art",
                            "values": [
                                {"id": "1", "name": "Indisch"},
                                {"id": "3", "name": "Schweiz"},
                                {"id": "2", "name": "Tessin"}
                            ]
                        }
                    ],
                    "products": [
                        {
                            "price_in_cents": 10000,
                            "image": <Image(75, 75)>,
                            "configuration": {
                                "1": 1
                            },
                            "id": 1,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        },
                        {
                            "price_in_cents": 10000,
                            "image": <Image(75, 75)>,
                            "configuration": {
                                "1": 2
                            },
                            "id": 3,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        },
                        {
                            "price_in_cents": 10000,
                            "image": <Image(75, 75)>,
                            "configuration": {
                                "1": 3
                            },
                            "id": 4,
                            "name": "Gutschein für eine Mahlzeit",
                            "requires_shipping_address": true
                        }
                    ]
                }
            }

# Group Categories
A deal can have a category.

## Error-Codes:
* 40: (HTTP 404 - NotFound) "Category not found" - The card does not exist in the database (anymore).
    When a deal cannot be collected anymore, the unsold cards are removed.
* 50: (HTTP 404 - NotFound) "No Deal found" - This deal never existed or the search returned no results
* 51: (HTTP 403 - Forbidden) "Cannot access deal" - This deal is not yet active

## Category collection [/categories]

### All active categories [GET]

+ Response 200 (application/json)

    + Headers
    
            Cache-Control: max-age=3600
            Date: Tue, 22 Apr 2014 15:46:23 GMT
            Expires: Tue, 22 Apr 2014 16:46:23 GMT
    
    + Body

            {
                "categories": [
                    {
                        "id": 1,
                        "name": "Reisen",
                        "icon": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/travel.png",
                        "rank": 1,
                    },
                    {
                        "id": 2,
                        "name": "Fashion",
                        "icon": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/fashion.png",
                        "rank": 2,
                    },
                    {
                        "id": 3,
                        "name": "Elektronik",
                        "icon": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/electronics.png",
                        "rank": 3,
                    },
                    {
                        "id": 4,
                        "name": "Haus & Heim",
                        "icon": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/home.png",
                        "rank": 4,
                    },
                    {
                        "id": 5,
                        "name": "Auto & Moto",
                        "icon": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/automoto.png",
                        "rank": 5,
                    },
                    {
                        "id": 6,
                        "name": "Freizeit & Sport",
                        "icon": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/fun.png",
                        "rank": 6,
                    },
                    {
                        "id": 7,
                        "name": "Essen & Genuss",
                        "icon": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/food.png",
                        "rank": 7,
                    },
                    {
                        "id": 8,
                        "name": "Beauty & Wellness",
                        "icon": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/beauty.png",
                        "rank": 8,
                    },
                    {
                        "id": 9,
                        "name": "Luxus",
                        "icon": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/kiss.png",
                        "rank": 9,
                    },
                ]
            }


# Group CardUnits
A cardunit describes the different cards collectable. A user can have multiple identical cards, but to redeem a deal it
is necessary to have at least one card belonging to each of the cardunits of the deal.

## CardUnit [/cardUnits/{dealid}]

### Cardunits of a deal[GET]

+ Parameters
    + dealid (int, required, `1012`) ... ID of the deal
    
+ Response 200 (application/json)

    + Body

            {
                "cardUnits": [
                    {
                        "image": <Image(66, 88)>,
                        "deal_id": 1012,
                        "number": 1,
                        "name": "04.1"
                    },
                    {
                        "image": <Image(66, 88)>,
                        "deal_id": 1012,
                        "number": 2,
                        "name": "04.2"
                    },
                    {
                        "image": <Image(66, 88)>,
                        "deal_id": 1012,
                        "number": 3,
                        "name": "04.3"
                    },
                    {
                        "image": <Image(66, 88)>,
                        "deal_id": 1012,
                        "number": 4,
                        "name": "04.4"
                    }
                ]
            }

## single CardUnit [/cardUnits/{dealid}/{number}]

### Update a single cardunit [PUT]

+ Parameters
    + dealid (int, required, `1012`) ... ID of the deal
    + number (int, required, `2`) ... number of the cardunit

+ Request (application/json)

    + Body

            {
               "image": "https://s3-eu-west-1.amazonaws.com/dealini-assets/img/redesign/icons/fun.png",
            }

+ Response 200 (application/json)

    + Body

            {
                "cardUnit": {
                    "image": <Image(66, 88)>,
                    "deal_id": 1012,
                    "number": 2,
                    "name": "04.2"
                }
            }

## CardUnits Collection [/cardUnits]
Enumerates the different kind of cards available for all active deals.

Attributes:

* image: (Image) The image of the card.
* deal_id: (int) ID of the deal this cardunit belongs to
* number: (int) The identifier of the specific card inside a deal
* name: (string) The name of the card that is displayed to the players. Format and content may change

### All CardUnits of active Deals [GET]

+ Response 200 (application/json)

    + Headers
    
            Cache-Control: max-age=3600
            Date: Tue, 22 Apr 2014 15:46:23 GMT
            Expires: Tue, 22 Apr 2014 16:46:23 GMT

    + Body

            {
                "cardUnits": [
                    {
                        "image": <Image(66, 88)>,
                        "deal_id": 1012,
                        "number": 1,
                        "name": "04.1"
                    },
                    {
                        "image": <Image(66, 88)>,
                        "deal_id": 1012,
                        "number": 2,
                        "name": "04.2"
                    },
                    {
                        "image": <Image(66, 88)>,
                        "deal_id": 1012,
                        "number": 3,
                        "name": "04.3"
                    },
                    {
                        "image": <Image(66, 88)>,
                        "deal_id": 1012,
                        "number": 4,
                        "name": "04.4"
                    },
                    {
                        "image": <Image(66, 88)>,
                        "deal_id": 1013,
                        "number": 1,
                        "name": "10.1"
                    },
                    {
                        "image": <Image(66, 88)>,
                        "deal_id": 1013,
                        "number": 2,
                        "name": "10.2"
                    },
                    {
                        "image": <Image(66, 88)>,
                        "deal_id": 1013,
                        "number": 3,
                        "name": "10.3"
                    },
                    {
                        "image": <Image(66, 88)>,
                        "deal_id": 1013,
                        "number": 4,
                        "name": "10.4"
                    }
                ]
            }


# Group DealLikes
A player can show that he wants to collect a deal by liking it.

## DealLikes [/users/{user_id}/dealLikes/{deal_id}]

### DealLikes for a user [GET]

+ Parameters
    + user_id (int, required, `4809`) ... The ID of the user whoes likes should be fetched. *current* for the logged-in user

+ Response 200 (application/json)

    + Body

            {
                "dealLikes": [
                    {
                        "deal_id": 1012,
                        "user_id": 4809
                    },
                    {
                        "deal_id": 1013,
                        "user_id": 4809
                    }
                ]
            }

### Like a Deal [POST]

+ Parameters
    + user_id (string, required, `current`) ... The user liking a deal. Only *current* is allowed here.

+ Request (application/json)

    + Body

            {
                "deal_id": 1013,
                "user_id": 4809
            }

+ Response 200 (application/json)

    + Body

            {
                "dealLike": {
                    "deal_id": 1013,
                    "user_id": 4809
                }
            }

### Unlike a Deal [DELETE]

+ Parameters
    + user_id (string, required, `current`) ... The user liking a deal. Only *current* is allowed here.
    + deal_id (int, required, `1012`) ... ID of the deal which should be unliked

+ Response 204


# Group Trades

#### Error-Codes:
* 70: (HTTP 404 - NotFound) "Trade not found" - The requested trade could not be found
* 71: (HTTP 403 - Forbidden) "Not allowed to request a foreign trade" - The currently logged-in user tried to access a trade in which he is not part of
* 72: (HTTP 403 - Forbidden) "Cannot create trade, illegal participants or added cards" - You can only create trades where you are the from_user and where all cards belong to the players in the trade.
* 73: (HTTP 403 - Forbidden) "Cannot update trade state, invalid state transition" - Only some trade state changes are allowed.

## Trade [/trades/{id}]

Attributes of a trade:

* id: (int) The unique ID of the trade
* from_user_id: (int) ID of the user who sent the trade
* to_user_id: (int) ID of the user who recieved the trade
* state: (string) The current state the trade is in. Can be one of the following:

    > suggested: A trade which is suggested to the from_user user.  
    > sent: A trade offer sent to the to_user, ready for him to accept or decline.  
    > declined: The trade was declined by the to_user.  
    > accepted: Trade was successfull completed and the cards have been traded  
    > cancelled: Trade was cancelled by the from_user, no cards were exchanged  

* time_updated: (isodatetime) The last time the trade was changed.


+ Model (application/json)

    + Body

            {
                "trade": {
                    "id": 123,
                    "from_user": {
                        "id": 4809
                    },
                    "to_user": {
                        "id": 631,
                        "username": "Matthias",
                        "image": <Image(50, 50)>
                    },
                    "state": "sent",
                    "time_updated": "2013-12-31T23:59:59",
                    "trade_cards": [
                        {
                            "trade_id": 123,
                            "user_id": 4809,
                            "deal_id": 1012,
                            "number": 1,
                            "quantity": 1
                        },
                        {
                            "trade_id": 123,
                            "user_id": 631,
                            "deal_id": 1013,
                            "number": 1,
                            "quantity": 1
                        }
                    ]
                }
            }

### Get a single Trade [GET]

+ Parameters
    + id (int, required, `123`) ... ID of the trade to fetch

+ Response 200

    [Trade][]

### Change a trade state [PUT]

+ Parameters
    + id (int, required, `123`) ... ID of the trade to fetch

+ Request (application/json)

    + Body

            {
                "state": "sent"
            }

+ Response 200

    [Trade][]


## Trade collection [/trades{?state,from_user_id,to_user_id}]

### Get trades for a user for the different views [GET]

+ Parameters
    + state (string, required, `suggested`) ... Can be any of the states described as possible trade states. Parameter can also be named `state[]`
    + from_user_id = `current` (int, optional) ... The ID of the user who started the trade. *current* for the logged-in user.
    + to_user_id (int, optional) ... The ID of the user recieving the trade. *current* for the logged-in user.

+ Response 200 (application/json)

    + Body

            {
                "trades": [
                    {
                        "id": 123,
                        "from_user": {
                            "id": 4809
                        },
                        "to_user": {
                            "id": 631,
                            "username": "Matthias",
                            "image": <Image(50, 50)>
                        },
                        "state": "suggested",
                        "time_updated": "2013-12-31T23:59:59",
                        "trade_cards": [
                            {
                                "trade_id": 123,
                                "user_id": 4809,
                                "deal_id": 1012,
                                "number": 1,
                                "quantity": 1
                            },
                            {
                                "trade_id": 123,
                                "user_id": 631,
                                "deal_id": 1013,
                                "number": 1,
                                "quantity": 1
                            }
                        ]
                    }
                ]
            }

### Create a new trade [POST]

A new trade which is offered to another player. Special case is when the new trade gets created based on an existing
trade (parent_trade_id is set), in which case the old trade will automatically be declinded or cancelled.

Special case: sending cards to another user (without receiving any cards in return)
In this case, the state of the trade can be set to "accepted" directly, causing the trade to be finished in one call.

+ Request (application/json)

    + Body

            {
                "trade_cards": [
                    {
                        "user_id": 4809,
                        "deal_id": 1014,
                        "number": 1,
                        "quantity": 1
                    },
                    {
                        "user_id": 631,
                        "deal_id": 1012,
                        "number": 1,
                        "quantity": 1
                    }
                ],
                "to_user": {
                    "id": 631
                }
            }

+ Response 200

    [Trade][]


# Group AWS S3 Upload

To upload content (e.g. user pictures), it is necessary to get the credentials for the upload to S3. Our AWS Access Key ID is "AKIAI3YXKI54O575Y6WA".

The process of uploading a user picture is:
1. Get policy, key and signature by Posting an empty dict to /awsS3Uploads
2. Use a POST with enctype "multipart/form-data" and policy, key, success_action_status (must be "201") and signature as fields to upload the image
    (http://docs.aws.amazon.com/AmazonS3/latest/dev/HTTPPOSTForms.html)
3. After successful upload, update the image (PUT /users/{id} with {"image": key})

Limitations for userpic upload:
* Only images are allowed (Content-Type: "image/*")
* Max size is 4 MB
* The filename cannot be chosen, a random key will be generated
* The userpic can only be retrieved by using the name returned in the PUT response, as special URLs with formatted userpics will be generated

If the formular would be sent by a Browser, the minimal HTML code would have to look like this:

        <form action="https://dealini-userupload.s3.amazonaws.com/" method="post" enctype="multipart/form-data">
            <input type="hidden" name="key" value="userpics/akrwk45uksh3" />
            <input type="hidden" name="AWSAccessKeyId " value="AKIAI3YXKI54O575Y6WA" />
            <input type="hidden" name="Policy" value="eyAiZXhwaXJhdGlvbiI6ICIyMDA3LTEyLTAxVDEyOjAwOjAwLjAwMFoiLAogICJjb25kaXRpb25zIjogWwogICAgeyJidWNrZXQiOiAiam9obnNtaXRoIiB9LAogICAgWyJzdGFydHMtd2l0aCIsICIka2V5IiwgInVzZXIvZXJpYy8iXSwKICAgIHsiYWNsIjogInB1YmxpYy1yZWFkIiB9LAogICAgeyJyZWRpcmVjdCI6ICJodHRwOi8vam9obnNtaXRoLnMzLmFtYXpvbmF3cy5jb20vc3VjY2Vzc2Z1bF91cGxvYWQuaHRtbCIgfSwKICAgIFsic3RhcnRzLXdpdGgiLCAiJENvbnRlbnQtVHlwZSIsICJpbWFnZS8iXSwKICAgIHsieC1hbXotbWV0YS11dWlkIjogIjE0MzY1MTIzNjUxMjc0In0sCiAgICBbInN0YXJ0cy13aXRoIiwgIiR4LWFtei1tZXRhLXRhZyIsICIiXSwKICBdCn0K" />
            <input type="hidden" name="Signature" value="2qCp0odXe7A9IYyUVqn0w2adtCA=" />
            <input type="hidden" name="success_action_status" value="201" />
            File: <input type="file" name="file" />
            <input type="submit" name="submit" value="Upload to Amazon S3" />
        </form>

## Error Codes
* 190: (HTTP 403 - Forbidden) "Uploading with this resource type is forbidden"

## AWSS3Upload collection [/awsS3Uploads]

### Create new Credentials [POST]
The following parameters are available:

* type: (unicode string) either "userpics" (default) or "content" (admins only)
* key: (unicode string) For "content" type upload only: use this exact filename.
* extension: (unicode string) extension of the file

+ Request for userpic upload (application/json)

        {}

+ Response 200

    + Body
    
            {
                "awsS3Upload": {
                    "policy": "eyJjb25kaXRpb25zIjogW3siYnVja2V0IjogImRlYWxpbmktdXNlcnVwbG9hZCJ9LCB7ImtleSI6ICJ1c2VycGljL2tCSWdUYXJUYnY1RyJ9LCBbInN0YXJ0cy13aXRoIiwgIiRDb250ZW50LVR5cGUiLCAiaW1hZ2UvIl0sIFsiY29udGVudC1sZW5ndGgtcmFuZ2UiLCAwLCA0MTk0MzA0XSwgeyJzdWNjZXNzX2FjdGlvbl9zdGF0dXMiOiAiMjAxIn1dLCAiZXhwaXJhdGlvbiI6ICIyMDE0LTA2LTExVDA4OjA3OjM4WiJ9",
                    "key": "userpic/kBIgTarTbv5G",
                    "signature": "M0atzCtWogLrYFT8338RUsfGVCA="
                }
            }

# Group Dashboard

## Session collection [/dashboard/sessions]

## Error-Codes
* 120: (HTTP 401 - Unauthorized) "Email or password did not match" 
* 121: (HTTP 401 - Unauthorized) "Session does not exist"

### Create a new Session with Email and Password [POST]
The following parameters are available:

* email: (unicode string) login of user
* password: (unicode string) password of user

+ Request (application/json)

        {
            "email": "dealiniadmin@dealini.ch",
            "password": "de-a-lini-admin"
        }

+ Response 200

    + Headers
    
            Set-Cookie: dealinidev_auth=5b068891ae586391d30c4aeed158ce5a6829af58b5bb9280f22c46689c9314b61482edf8; httponly; Path=/
            Access-Control-Allow-Credentials: true
    
    + Body
    
            {
                "session": {
                    "token": "5b068891ae586391d30c4aeed158ce5a6829af58b5bb9280f22c46689c9314b61482edf8",
                    "userid": 288
                }
            }

### Return permissions of setting sessions [OPTIONS]

+ Response 200

    + Headers
    
            Access-Control-Allow-Credentials: true

## Session [/dashboard/sessions/current]

### Return permissions of setting sessions [OPTIONS]

+ Response 200

    + Headers
    
            Access-Control-Allow-Credentials: true

### Logout a user [DELETE]

+ Response 204
    
    + Headers
            
            Access-Control-Allow-Credentials: true
            Set-Cookie: dealinidev_auth=5b068891ae586391d30c4aeed158ce5a6829af58b5bb9280f22c46689c9314b61482edf8; expires=Mon, 18-Feb-2013 12:17:57 GMT; httponly; Path=/

## Dashboarduser collection [/dashboard/dashboardusers]

## Error-Codes
* 130: (HTTP 404 - NotFound) "No User found" - There is no user with the provided ID
* 131: (HTTP 403 - Forbidden) "Email already exists" - A user with the same email address already registered.

### Get user info [GET]

+ Response 200

    + Body
    
            {
                "dashboardusers": [
                    {"id": 98, "email": "michael.wirth@dealini.ch", "last_login": "2014-02-01T08:15:30+01:00", "active": true},
                    {"id": 99, "email": "pascal.fierz@dealini.ch", "last_login": "2013-11-21T08:15:30+01:00", "active": true},
                    {"id": 100, "email": "rene@thebeach.ch", "last_login": "2013-12-25T10:15:30+01:00", "active": true},
                    {"id": 101, "email": "tamara.ambrosini@dealini.ch", "last_login": "2013-11-21T08:15:30+01:00", "active": true},
                    {"id": 102, "email": "mw@monotone.ch", "last_login": "2014-04-01T01:15:30+01:00", "active": true},
                    {"id": 103, "email": "jean-paul.saija@dealini.ch", "last_login": "2013-01-29T08:15:30+01:00", "active": true},
                    {"id": 104, "email": "fabian.brun@dealini.ch", "last_login": "2013-10-11T08:15:30+01:00", "active": true},
                    {"id": 105, "email": "taotao@hotmail.de", "last_login": "2013-11-21T08:15:30+01:00", "active": true},
                    {"id": 106, "email": "donymeca@gmail.com", "last_login": "2014-01-05T18:35:30+01:00", "active": true},
                    {"id": 107, "email": "unpluggd@gmail.com", "last_login": "2013-10-21T08:15:30+01:00", "active": true},
                    {"id": 108, "email": "beat.merkli@six-group.com", "last_login": "2013-08-11T08:15:30+01:00", "active": true},
                    {"id": 109, "email": "boostup@gmx.ch", "last_login": "2013-11-21T08:15:30+01:00", "active": true},
                    {"id": 110, "email": "francisco@jent.ch", "last_login": "2014-03-08T05:15:30+01:00", "active": true},
                    {"id": 111, "email": "wiseveri@student.ethz.ch", "last_login": "2013-09-19T08:15:30+01:00", "active": true},
                    {"id": 112, "email": "daniela.paris@hosg.ch", "last_login": "2013-12-03T08:15:30+01:00", "active": true},
                    {"id": 113, "email": "marc.waber@swissonline.ch", "last_login": "2013-11-21T08:15:30+01:00", "active": true},
                    {"id": 114, "email": "eavdyli@hispeed.ch", "last_login": "2014-01-21T08:15:30+01:00", "active": true},
                    {"id": 115, "email": "cisco@jent.ch", "last_login": "2013-11-21T08:15:30+01:00", "active": true},
                    {"id": 116, "email": "james@prodigi.ch", "last_login": "2014-01-30T08:15:30+01:00", "active": true}
                ]
            }

## Dashboarduser [/dashboard/dashboardusers/{id}]

### Get user info [GET]

+ Parameters
    + id (int, required, `288`) ... ID of the user to fetch. Use `current` for the logged-in user.

+ Response 200

    + Body
    
            {
                "dashboarduser": {
                    "id": 288,
                    "email": "james@prodigi.ch", 
                    "last_login": "2013-11-21T08:15:30+01:00", 
                    "active": true,
                    "roles": ["bp", "admin"],
                    "permissions": ["main", "register", "settings", "permissions"]
                }
            }

## Permission collection [/dashboard/permissions]

### Get all permissions [GET]

+ Response 200

    + Body
    
            {
                "permissions": [
                    {"id": 1, "name": "settings"},
                    {"id": 2, "name": "redemptions"},
                    {"id": 3, "name": "statistics"}
                ]
            }

## Roles Collection [/dashboard/roles]

* 140: (HTTP 403 - Forbidden) "Rolename already exists" - A role with the same name already registered.

### Get all role permission connections [GET]

+ Response 200

    + Body
    
            {
                "roles": [
                    {"id": 1, "name": "admin", "permissions": []},
                    {"id": 2, "name": "investor", "permissions": [{"id": 1}, {"id": 2}]},
                    {"id": 3, "name": "bp",  "permissions": [{"id": 2}, {"id": 3}]}
                ]
            }

## Role [/dashboard/roles/{id}]

### Update role [PUT]

+ Parameters
    + id (int, required, `3`) ... ID of the role
    
+ Request (application/json)

    + Body
    
            {
                "permissions": [{"id": 1}, {"id": 3}]
            }
            
+ Response 200
    
    + Body
    
            {
                "role": {"id": 3, "name": "bp",  "permissions": [{"id": 1}, {"id": 3}]}
            }
 

# Group Product

#### Error-Codes:
* 110: (HTTP 403 - Forbidden) "No Product found" - Unknown product.

## Product [/products/{id}]

A product describes something which can be bought / redeemed

Attributes of a product:

* id: (int) ID of the product
* name: (string) Short descriptive name of the product
* price_in_cents: (int) The products price in cents (Rappen)
* image: (Image) The image of the product
* configuration: (dict) The option for this product. Options are configured on the deal.
* requires_shipping_address: (boolean) If a shipping address must be asked from the buyer.
* requires_payment: (boolean) If a payment must be done for this product before a successful redemption
* shipping_costs_in_cents: (int) The price for the shipping costs in cents (Rappen)


+ Model (application/json)

    + Body

            {
                "product": {
                    "id": 1,
                    "deal_id": 1012,
                    "name": "Gutschein für eine Mahlzeit",
                    "price_in_cents": 10000,
                    "image": <Image(75, 75)>,
                    "configuration": {"1": 1},
                    "requires_shipping_address": true,
                    "requires_payment": true,
                    "shipping_costs_in_cents": 0
                }
            }

### Get a single product [GET]

+ Parameters
    + id (int, required, `1`) ... ID of the product to fetch

+ Response 200

    [Product][]

## Products of a deal [/deals/{id}/products]

### Get the products of a deal [GET]

+ Parameters
    + id (int, required, `1012`) ... ID of the deal for which the products should be fetched

+ Response 200

    + Body

            {
                "products": [
                    {
                        "id": 1,
                        "deal_id": 1012,
                        "name": "Gutschein für eine Mahlzeit",
                        "price_in_cents": 10000,
                        "image": <Image(75, 75)>,
                        "configuration": {"1": 1},
                        "requires_shipping_address": true,
                        "requires_payment": true,
                        "shipping_costs_in_cents": 0
                    },
                    {
                        "id": 2,
                        "deal_id": 1012,
                        "name": "Gutschein für eine Mahlzeit",
                        "price_in_cents": 10000,
                        "image": <Image(75, 75)>,
                        "configuration": {"1": 2},
                        "requires_shipping_address": true,
                        "requires_payment": true,
                        "shipping_costs_in_cents": 0
                    },
                    {
                        "id": 3,
                        "deal_id": 1012,
                        "name": "Gutschein für eine Mahlzeit",
                        "price_in_cents": 10000,
                        "image": <Image(75, 75)>,
                        "configuration": {"1": 3},
                        "requires_shipping_address": true,
                        "requires_payment": true,
                        "shipping_costs_in_cents": 0
                    }
                ]
            }


# Group Order

#### Error-Codes:
* 100: (HTTP 403 - Forbidden) "Product out of stock" - There are no more products available to be ordered
* 101: (HTTP 403 - Forbidden) "User doesn't own enough cards" - To redeem, the user must have all numbers of the products deal.
* 102: (HTTP 403 - Forbidden) "Cannot access order of another player" - Only the orders of the logged-in user may be retrieved.
* 103: (HTTP 404 - NotFound) "No order found" - Order does not exist.
* 104: (HTTP 403 - Forbidden) "Invalid update, order is read-only" - Once the order is paid, no updates can be issued by the player
* 105: (HTTP 403 - Forbidden) "Invalid update, invalid status change from old_status to new_status" - Only some order status changes are allowed:

    > reserved -> paid: Mark an order as paid. The server will check if the address and payment are complete.

* 106: (HTTP 403 - Forbidden) "Invalid order, cannot be paid" - The order got invalid during the reservation (out of stock or cards traded).
* 107: (HTTP 403 - Forbidden) "Transaction already recorded" - The transaction ID is already used. Most likely the receipt was accidentially sent twice.


## Order [/orders/{id}]

An order corresponds to a user buying a product.

Ordering a product usually involves the following steps:

1. Prepare an order by creating a new empty order. It will expire after 15min (POST /orders)
2. Update (PUT) the product chosen by the user. This will automatically extend the orders reservation time.
3. Update (PUT) the necessary shipping information. This will automatically extend the orders reservation time.
4. Process the payment using Datatrans. The payments refid and signature are provided in the `payment` object ("id" and "sign").
5. If no payment is necessary (e.g. if the price is 0), the order is paid by setting the status to "paid" (PUT).
6. Refresh the order if necessary, e.g. after processing the payment from datatrans. The status should be "paid" now.

Special cases:

* Reservation times out, but order is still possible: The order is re-opened and used as if it never expired

Attributes:

* id: (int) ID of the order
* product: (Product) The product which got ordered
* user_id: (int) ID of the user who ordered this product
* status: (string) Descriptive status of the orders state. Possible states:

    > * reserved: The order is not yet completed, but the product is reserved for the user. Reservations time out after 15 minutes.
    > * paid: The order was completed successfully, e.g. the payment was received and the cards were redeemed.
    > * more states will be defined to tell the user about the orders progress (e.g. shipping date & progress)
    
* status_formatted: (string) The status of the order as it can be displayed to the user (e.g. "Ausgeliefert").
* time_ordered: (isodatetime) The time when the order was made (e.g. after successful payment / redemption)

+ Model (application/json)

    + Body

            {
                "order": {
                    "id": 1,
                    "product": {
                        "id": 1,
                        "deal_id": 1012,
                        "name": "Gutschein für eine Mahlzeit",
                        "price_in_cents": 10000,
                        "image": <Image(75, 75)>,
                        "configuration": {"1": 1},
                        "requires_shipping_address": true,
                        "requires_payment": true,
                        "shipping_costs_in_cents": 0
                    },
                    "user_id": 82887,
                    "payment": {
                        "id": 34567,
                        "sign": "089652cb68092e6fb321d15cd4f507be"
                    },
                    "billing_address": {
                        "title": "Mr",
                        "first_name": "Max",
                        "last_name": "Mustermann",
                        "street": "Strasse 1",
                        "postal_code": "1234",
                        "city": "Stadt",
                        "country_iso_code": "CH"
                    },
                    "status": "paid",
                    "status_formatted": "Bezahlt",
                    "time_ordered": "2014-03-10T23:59:59"
                }
            }

### Get a single order [GET]

+ Parameters
    + id (int, required, `1`) ... ID of the oder to fetch

+ Response 200

    [Order][]

### Update an order [PUT]

The following fields can be changed:

* address: (Address) The billing address. Used as shipping address if no shipping address is defined.
* status: (string) Can be set to "paid" for orders where no payment is necessary (e.g. where the product is free)
* product: (Product) The product which should be ordered. Can be changed until the payment is processed.

+ Parameters
    + id (int, required, `1`) ... ID of the oder to update

+ Request (application/json)

        {
            "product": {
                "id": 1
            },
            "billing_address": {
                "title": "Mr",
                "first_name": "Max",
                "last_name": "Mustermann",
                "street": "Strasse 1",
                "postal_code": "1234",
                "city": "Stadt",
                "country_iso_code": "CH"
            },
            "status": "paid"
        }

+ Response 200

    [Order][]

## Order Collection [/orders]

### Show all orders for the logged-in user [GET]

+ Response 200

    + Body
    
            {
                "orders": [
                    {
                        "id": 1,
                        "product": {
                            "id": 1,
                            "deal_id": 1012,
                            "name": "Gutschein für eine Mahlzeit",
                            "price_in_cents": 10000,
                            "image": <Image(75, 75)>,
                            "configuration": {"1": 1},
                            "requires_shipping_address": true,
                            "requires_payment": true,
                            "shipping_costs_in_cents": 0
                        },
                        "user_id": 82887,
                        "payment": {
                            "id": 1,
                            "payment_mean": {
                                "id": 1,
                                "holder": "Max Mustermann",
                                "type": "visa",
                                "alias": "12345678901234567",
                                "card_number_suffix": "1234",
                                "expiry_date": "2016-09-01"
                            }
                        },
                        "billing_address": {
                            "title": "Mr",
                            "first_name": "Max",
                            "last_name": "Mustermann",
                            "street": "Strasse 1",
                            "postal_code": "1234",
                            "city": "Stadt",
                            "country_iso_code": "CH"
                        },
                        "status": "paid",
                        "status_formatted": "Bezahlt",
                        "time_ordered": "2014-03-10T23:59:59"
                    }
                    {
                        "id": 2,
                        "product": {
                            "id": 2,
                            "deal_id": 1013,
                            "name": "Gutschein für ein Festmahl",
                            "price_in_cents": 12323,
                            "image": <Image(75, 75)>,
                            "configuration": {"1": 1},
                            "requires_shipping_address": true,
                            "requires_payment": true,
                            "shipping_costs_in_cents": 0
                        },
                        "user_id": 82887,
                        "payment": {
                            "id": 2,
                            "payment_mean": {
                                "id": 1,
                                "holder": "Max Mustermann",
                                "type": "visa",
                                "alias": "12345678901234567",
                                "card_number_suffix": "1234",
                                "expiry_date": "2016-09-01"
                            }
                        },
                        "billing_address": {
                            "title": "Herr",
                            "first_name": "Max",
                            "last_name": "Mustermann",
                            "street": "Strasse 1",
                            "postal_code": "1234",
                            "city": "Stadt",
                            "country_iso_code": "CH"
                        },
                        "status": "reserved",
                        "status_formatted": "Reserviert (15min)",
                        "time_ordered": "2014-03-10T23:59:59"
                    }
                ]
            }

### Create a new order [POST]

Fields which can be set during creation (all optional):
* product_id: (int) ID of the product for this order
* user_id: (int) ID of the user who orders
* payment: (PaymentRequestObject) For an inapp-purchase the order can directly be paid

#### PaymentRequestObject
When creating an order, it can be directly paid using an inapp payment from apple or google.
* apple_receipt: (base64 encoded string) The receipt received from apple after the inapp payment by the app
* google_token: (string) Token received from the google play store after the inapp payment
* google_product_id: (string) The product which was ordered as stored inside the google play store.

#### Google Payment process
During the payment process, it is necessary to create a "developerPayload" which is used as the unique transaction ID.
The app must create a random unsigned integer up to 8 bytes long (0-18'446'744'073'709'551'615) to make the transaction unique.
This unique transaction ID must be sent to google when doing the payment
and is later given to the API server (by the Google Developer API) during payment validation.

+ Request (application/json)

        {}

+ Response 200 (application/json)

    + Body

            {
                "order": {
                    "id": 1,
                    "product": null,
                    "user_id": 82887,
                    "payment": null,
                    "billing_address": {
                        "title": "Mr",
                        "first_name": "",
                        "last_name": "",
                        "street": "",
                        "postal_code": "",
                        "city": "",
                        "country_iso_code": "CH"
                    },
                    "status": "reserved",
                    "status_formatted": "Reserviert",
                    "time_ordered": "2014-03-10T23:59:59"
                }
            }



# Group PaymentMeans

A payment mean holds a credit card or similar ways to pay online (e.g. a Postcard).

#### Error-Codes
* 150: (HTTP 403 - NotFound) "PaymentMean not found" - This payment mean does not exist in our database (anymore)
* 151: (HTTP 403 - Forbidden) "Cannot access payment mean of another user" - Only payment means owned by the logged-in user can be delete

## PaymentMean [/paymentMeans/{id}]

Attributes:
* id: (int) ID of the payment mean.
* type: (string) Can be `visa` / `mastercard` or `postcard`.
* holder: (string) Name of the holder of the card
* alias: (string) A unique identifier of this card used by DataTrans.
  Can be used to identify the card without having to provide the full data again
* card_number_suffix: (string) The last 4 digits of the card. Usefull to show the user which card he has stored.
* expiry_date: (string) Isodate of the first day of the month where the card expires

+ Model (application/json)

    + Body

            {
                "paymentMean": {
                    "id": 1,
                    "holder": "Max Mustermann",
                    "type": "visa",
                    "alias": "12345678901234567",
                    "card_number_suffix": "1234",
                    "expiry_date": "2014-09-01",
                }
            }

### Remove a payment mean [DELETE]

+ Response 204

## PaymentMean Collection [/paymentMeans]

### Get all PaymentMeans of the logged-in user [GET]

+ Response 200

    + Body
    
            {
                "paymentMeans": [
                    {
                        "id": 1,
                        "holder": "Max Mustermann",
                        "type": "visa",
                        "alias": "12345678901234567",
                        "card_number_suffix": "1234",
                        "expiry_date": "2014-09-01",
                    },
                    {
                        "id": 2,
                        "holder": "Max Mustermann",
                        "type": "mastercard",
                        "alias": "76543210987654321",
                        "card_number_suffix": "4321",
                        "expiry_date": "2014-09-01",
                    },
                ]
            }

### Register a new PaymentMean [POST]

A payment mean should only be registered if it is checked and valid, e.g. after it was used in a payment for the first time.

+ Request (application/json)

        {
            "type": "visa",
            "holder": "Max Mustermann",
            "alias": "12345678901234567",
            "card_number_suffix": "1234",
            "expiry_date": "2014-09-01"
        }

+ Response 200

    [PaymentMean][]


# Group Notifications

Notifications are generated by various actions, initiated by the user or the server.
We are using parse to send push notifications to the mobile devices (using the users push_notification_channel)

Each mobile device should register to the push_notification_channel of the logged-in user
(see https://www.parse.com/docs/push_guide#sending-channels/Android or https://www.parse.com/docs/push_guide#sending-channels/iOS)

For every push notification, the following fields are set:

* alert: (string) The text of the message
* badge: (string, 'increment') Always set to "increment" to make parse do the counting.
* content-available: (int, 1) Always active to allow push notifications without the app being active

The data sent using push notifications is limited by apples 255 byte limit.
For this reason, we are sending a subset of fields with shorter names as part of the "data":

* code: (int) The code of the notification, used to call the correct action
* i: (string) URL of the image which should be displayed next to the notification

#### Error-Codes:
* 110: (HTTP 404 - NotFound) "Could not find notification" - The requested notification does not exist.
* 111: (HTTP 404 - NotFound) "Cannot access notification of another player" - Only notifications of the logged-in user may be accessed.
* 112: (HTTP 404 - NotFound) "Invalid notification change" - Cannot un-see or un-consume notification.

## Possible Notifications
* code: 0; message: "Neues Tauschangebot erhalten" - issued after trade creation (POST /trades), not used right now
* code: 3; message: "%s möchte dich als Freund hinzufügen." - created after friendship request (POST /users/{user_id}/friendRequests)
* code: 4; message: "%s hat dich als Freund hinzugefügt." - created after successful friendship (POST /users/{user_id}/friendship)

## Notification [/notifications/{id}]

### Notification

+ Model (application/json)

    + Body

            {
                "notification": {
                    "id": 1,
                    "code": 1,
                    "consumed": false,
                    "seen": true,
                    "text": "Neues Tauschangebot erhalten",
                    "image": <Image(50, 50)>,
                    "time_created": "2014-05-26T08:32:22"
                }
            }

### Mark notification as consumed or seen [PUT]

+ Parameters
    + id (int, required, `1`) ... ID of the notification to update

+ Request (application/json)

        {
            "consumed": true
        }

+ Response 200 (application/json)

    [Notification][]

## Notification collection [/notifications]

### Get all notifications for current user [GET]

+ Response 200 (application/json)

    + Body
    
            {
                "notifications": [
                    {
                        "id": 1,
                        "code": 0,
                        "consumed": false,
                        "seen": false,
                        "text": "Neues Tauschangebot erhalten",
                        "image": <Image(50, 50)>,
                        "time_created": "2014-05-26T08:32:22"
                    },
                    {
                        "id": 2,
                        "code": 1,
                        "consumed": false,
                        "seen": false,
                        "text": "Tauschangebot akzeptiert",
                        "image": <Image(50, 50)>,
                        "time_created": "2014-05-26T08:32:22"
                    },
                    {
                        "id": 3,
                        "code": 2,
                        "consumed": false,
                        "seen": false,
                        "text": "Tauschangebot abgelehnt",
                        "image": <Image(50, 50)>,
                        "time_created": "2014-05-26T08:32:22"
                    },
                    {
                        "id": 4,
                        "code": 0,
                        "consumed": true,
                        "seen": true,
                        "text": "Neues Tauschangebot erhalten",
                        "image": <Image(50, 50)>,
                        "time_created": "2014-05-26T08:32:22"
                    },
                    {
                        "id": 5,
                        "code": 1,
                        "consumed": true,
                        "seen": true,
                        "text": "Tauschangebot akzeptiert",
                        "image": <Image(50, 50)>,
                        "time_created": "2014-05-26T08:32:22"
                    }
                ]
            }

### Update all notifications of the logged-in user [PUT]

Return the newest 10 notifications, independent if they were changed or not

+ Request (application/json)

        {
            "consumed": true
        }

+ Response 200 (application/json)

    + Body
    
            {
                "notifications": [
                    {
                        "id": 1,
                        "code": 0,
                        "consumed": true,
                        "seen": false,
                        "text": "Neues Tauschangebot erhalten",
                        "image": <Image(50, 50)>,
                        "time_created": "2014-05-26T08:32:22"
                    },
                    {
                        "id": 2,
                        "code": 1,
                        "consumed": true,
                        "seen": false,
                        "text": "Tauschangebot akzeptiert",
                        "image": <Image(50, 50)>,
                        "time_created": "2014-05-26T08:32:22"
                    }
                ]
            }

## Reset Password [/ResetPassword]

Send a 'Reset Password' mail and reset password

### Send reset password mail [POST]

+ Request (application/json)

    + Body
    
            {
                "email": "dealinitest1@dealini.ch",
            }
            
+ Response 204

### Reset password [PUT]
    
+ Request (application/json)

    + Body
    
            {
                "email": "dealinitest1@dealini.ch",
                "password": "bla123",
                "reset_token": "q7H6kw25Fd",
            }
            
+ Response 204
